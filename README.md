# Лабораторная работа #6
* Разделить программу из лабораторной работы №5 на клиентский и серверный модули. Серверный модуль должен осуществлять выполнение команд по управлению коллекцией. Клиентский модуль должен в интерактивном режиме считывать команды, передавать их для выполнения на сервер и выводить результаты выполнения.

***Необходимо выполнить следующие требования:***

* Операции обработки объектов коллекции должны быть реализованы с помощью Stream API с использованием лямбда-выражений.
* Объекты между клиентом и сервером должны передаваться в сериализованном виде.
* Объекты в коллекции, передаваемой клиенту, должны быть отсортированы по местоположению
* Клиент должен корректно обрабатывать временную недоступность сервера.
* Обмен данными между клиентом и сервером должен осуществляться по протоколу TCP
* Для обмена данными на сервере необходимо использовать сетевой канал
* Для обмена данными на клиенте необходимо использовать потоки ввода-вывода
* Сетевые каналы должны использоваться в неблокирующем режиме.

***Обязанности серверного приложения:***

* Работа с файлом, хранящим коллекцию.
* Управление коллекцией объектов.
* Назначение автоматически генерируемых полей объектов в коллекции.
* Ожидание подключений и запросов от клиента.
* Обработка полученных запросов (команд).
* Сохранение коллекции в файл при завершении работы приложения.
* Сохранение коллекции в файл при исполнении специальной команды, доступной только серверу (клиент такую команду отправить не может).
* Серверное приложение должно состоять из следующих модулей (реализованных в виде одного или нескольких классов):
* Модуль приёма подключений.
* Модуль чтения запроса.
* Модуль обработки полученных команд.
* Модуль отправки ответов клиенту.
* Сервер должен работать в однопоточном режиме.

***Обязанности клиентского приложения:***

* Чтение команд из консоли.
* Валидация вводимых данных.
* Сериализация введённой команды и её аргументов.
* Отправка полученной команды и её аргументов на сервер.
* Обработка ответа от сервера (вывод результата исполнения команды в консоль).
* Команду save из клиентского приложения необходимо убрать.
* Команда exit завершает работу клиентского приложения.

***Дополнительное задание:***
* Реализовать логирование различных этапов работы сервера (начало работы, получение нового подключения, получение нового запроса, отправка ответа и т.п.) с помощью Logback

***Отчёт по работе должен содержать:***
* Текст задания.
* Диаграмма классов разработанной программы (как клиентского, так и серверного приложения).
* Исходный код программы.
* Выводы по работе.

***Вопросы к защите лабораторной работы:***

* Сетевое взаимодействие - клиент-серверная архитектура, основные протоколы, их сходства и отличия.
* Протокол TCP. Классы Socket и ServerSocket.
* Протокол UDP. Классы DatagramSocket и DatagramPacket.
* Отличия блокирующего и неблокирующего ввода-вывода, их преимущества и недостатки. Работа с сетевыми каналами.
* Классы SocketChannel и DatagramChannel.
* Передача данных по сети. Сериализация объектов.
* Интерфейс Serializable. Объектный граф, сериализация и десериализация полей и методов.
* Java Stream API. Создание конвейеров. Промежуточные и терминальные операции.
* Шаблоны проектирования: Decorator, Iterator, Factory method, Command, Flyweight, Interpreter, Singleton, Strategy, Adapter, Facade, Proxy.

# Теория:
### 1. Сетевое взаимодействие - клиент-серверная архитектура, основные протоколы, их сходства и отличия.

Сетевое взаимодействие основано на клиент-серверной архитектуре, которая является одной из наиболее распространенных моделей в компьютерных сетях. В этой архитектуре компьютеры разделяются на два типа: клиенты и серверы.
* Клиенты - это устройства или программы, которые запрашивают данные или услуги у сервера.
* Серверы - это устройства или программы, которые предоставляют данные или услуги клиентам.

Основные протоколы, используемые в клиент-серверной архитектуре:

* HTTP (Hypertext Transfer Protocol): Этот протокол используется для передачи гипертекстовых документов в сети. Он является основным протоколом для веб-серверов и веб-браузеров.
* HTTPS (Hypertext Transfer Protocol Secure): Это расширение HTTP с использованием криптографии для обеспечения безопасной передачи данных между клиентом и сервером. Обычно используется для защиты конфиденциальной информации, такой как данные банковских транзакций или личная информация пользователей.
* TCP (Transmission Control Protocol): Этот протокол обеспечивает надежную доставку данных между устройствами в сети. Он разбивает данные на пакеты, управляет потоком и контролирует передачу данных.
* UDP (User Datagram Protocol): В отличие от TCP, UDP является протоколом без установления соединения и не гарантирует доставку данных. Он часто используется для передачи потоковых данных, где потеря пакетов не так критична, как в случае с реальным временем или потоковым видео.

Сходства и отличия между протоколами:

* HTTP и HTTPS: Оба протокола используются для передачи данных между клиентом и сервером, но HTTPS обеспечивает дополнительный уровень безопасности за счет шифрования данных.
* TCP и UDP: Оба протокола используются для передачи данных в сети, но TCP обеспечивает надежную доставку данных и контроль потока, в то время как UDP предлагает более быструю передачу без гарантии доставки.

В целом, выбор протокола зависит от конкретных требований приложения: если важна надежность и целостность данных, то предпочтительнее использовать TCP; если важна скорость и потеря пакетов не критична, то UDP может быть более подходящим выбором. В контексте веб-программирования, HTTPS обеспечивает безопасное взаимодействие между веб-браузерами и серверами, что особенно важно для защиты конфиденциальной информации пользователей.

### 2. Протокол TCP. Классы Socket и ServerSocket.
* Протокол TCP (Transmission Control Protocol) является одним из основных протоколов передачи данных в компьютерных сетях. Он обеспечивает надежную, упорядоченную и проверенную передачу данных между устройствами
* В Java, для работы с TCP-соединениями используются классы Socket и ServerSocket из пакета java.net.

***Socket: Класс Socket представляет собой конечную точку соединения между двумя устройствами по протоколу TCP. В Java он используется для создания клиентских соединений. Этот класс обеспечивает сокет для обмена данными с сервером. Как только сокет создан, клиент может использовать его для отправки и получения данных через TCP-соединение.
Пример использования Socket в Java для подключения к серверу:***

```java
import java.net.*;
import java.io.*;

public class Client {
    public static void main(String[] args) {
        try {
            Socket socket = new Socket("сервер", порт);
            // Теперь можно отправлять и получать данные через объект socket
            InputStream inputStream = socket.getInputStream();
            OutputStream outputStream = socket.getOutputStream();
            // ...
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

***ServerSocket: Класс ServerSocket представляет собой сокет, который ожидает запросы на входящее TCP-соединение. Когда серверный сокет принимает запрос на соединение от клиента, он создает новый сокет на сервере, который используется для общения с этим клиентом.
Пример использования ServerSocket в Java для создания сервера:***

```java
import java.net.*;
import java.io.*;

public class Server {
    public static void main(String[] args) {
        try {
            ServerSocket serverSocket = new ServerSocket(порт);
            while (true) {
                Socket socket = serverSocket.accept(); // ждем подключения клиента
                // Теперь можно общаться с клиентом через объект socket
                InputStream inputStream = socket.getInputStream();
                OutputStream outputStream = socket.getOutputStream();
                // ...
                socket.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
Эти классы позволяют Java-приложениям создавать TCP-соединения и обмениваться данными с другими приложениями по сети.

### 3. Протокол UDP. Классы DatagramSocket и DatagramPacket.
* Протокол UDP (User Datagram Protocol) представляет собой простой протокол передачи данных, который не гарантирует надежную и упорядоченную доставку пакетов, как это делает TCP. Вместо этого UDP обеспечивает более быструю передачу данных без установления соединения и без подтверждения доставки.

* В Java для работы с UDP-соединениями используются классы DatagramSocket и DatagramPacket из пакета java.net.

***Сначала создадим UDP-сервер, который будет принимать датаграммы от клиентов и отсылать их обратно:***

```java
import java.net.*;

public class UDPServer {
    public static void main(String[] args) {
        try {
            // Создаем DatagramSocket, привязываем его к порту 12345
            DatagramSocket serverSocket = new DatagramSocket(12345);

            byte[] receiveData = new byte[1024];

            while (true) {
                // Создаем DatagramPacket для получения данных
                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);
                
                // Получаем датаграмму от клиента
                serverSocket.receive(receivePacket);
                
                // Получаем данные из датаграммы
                String receivedMessage = new String(receivePacket.getData(), 0, receivePacket.getLength());
                System.out.println("Received message from client: " + receivedMessage);
                
                // Отправляем датаграмму обратно клиенту
                InetAddress clientAddress = receivePacket.getAddress();
                int clientPort = receivePacket.getPort();
                byte[] sendData = receivedMessage.toUpperCase().getBytes();
                DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, clientAddress, clientPort);
                serverSocket.send(sendPacket);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

***Теперь создадим UDP-клиент, который будет отправлять сообщение на сервер и получать его обратно:***

```java 
import java.net.*;

public class UDPClient {
    public static void main(String[] args) {
        try {
            // Создаем DatagramSocket для отправки и получения датаграмм
            DatagramSocket clientSocket = new DatagramSocket();
            InetAddress serverAddress = InetAddress.getByName("localhost");
            int serverPort = 12345;

            // Отправляем датаграмму на сервер
            String message = "Hello, UDP Server!";
            byte[] sendData = message.getBytes();
            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, serverAddress, serverPort);
            clientSocket.send(sendPacket);
            System.out.println("Sent message to server: " + message);

            // Получаем датаграмму с сервера
            byte[] receiveData = new byte[1024];
            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);
            clientSocket.receive(receivePacket);
            
            // Получаем данные из датаграммы
            String receivedMessage = new String(receivePacket.getData(), 0, receivePacket.getLength());
            System.out.println("Received message from server: " + receivedMessage);

            // Закрываем сокет
            clientSocket.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
Эти примеры демонстрируют простой UDP-сервер и UDP-клиент, которые обмениваются сообщениями через датаграммы. Когда клиент отправляет сообщение на сервер, сервер принимает его, преобразует в верхний регистр и отправляет обратно клиенту.

### 4. Отличия блокирующего и неблокирующего ввода-вывода, их преимущества и недостатки. Работа с сетевыми каналами.

* Блокирующий и неблокирующий ввод-вывод (I/O) - это два подхода к обработке операций ввода-вывода в программировании.

*** Блокирующий ввод-вывод:***
* Принцип работы: При использовании блокирующего ввода-вывода операции блокируют поток выполнения, пока данные не будут доступны для чтения или записи. Это означает, что поток будет остановлен до тех пор, пока операция не будет завершена.
***Преимущества:***
* Прост в использовании и понимании.
* Подходит для простых приложений и сценариев, где необходима синхронная обработка данных.
***Недостатки:***
* Может привести к простаиванию (blokcing) других операций, если одна из операций I/O блокируется.
* Неэффективен при работе с большим количеством соединений или операциями, которые занимают много времени.

***Неблокирующий ввод-вывод:***
* Принцип работы: При использовании неблокирующего ввода-вывода операции I/O не блокируют поток выполнения. Вместо этого, операции возвращают управление немедленно, даже если данные еще не доступны для чтения или записи.
***Преимущества:***
* Позволяет обрабатывать несколько операций I/O параллельно в одном потоке.
* Используется в высоконагруженных системах для увеличения производительности.
***Недостатки:***
* Более сложен в использовании из-за необходимости контролировать состояние операций I/O.
* Может привести к увеличению сложности кода из-за необходимости управления событиями и состояниями.

***Работа с сетевыми каналами в Java на примере неблокирующего TCP-сервера:***

```java
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;

public class NonBlockingTCPServer {
    public static void main(String[] args) {
        try {
            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.socket().bind(new InetSocketAddress(12345));

            ByteBuffer buffer = ByteBuffer.allocate(1024);

            while (true) {
                SocketChannel socketChannel = serverSocketChannel.accept();
                if (socketChannel != null) {
                    System.out.println("Client connected: " + socketChannel.getRemoteAddress());

                    buffer.clear();
                    buffer.put("Hello, TCP Client!".getBytes());
                    buffer.flip();
                    while (buffer.hasRemaining()) {
                        socketChannel.write(buffer);
                    }

                    socketChannel.close();
                } else {
                    // Если нет новых клиентов, можно выполнить другие операции
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

***Пример неблокирующего TCP-клиента:***

```java
Copy code
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

public class NonBlockingTCPClient {
    public static void main(String[] args) {
        try {
            SocketChannel socketChannel = SocketChannel.open();
            socketChannel.configureBlocking(false);
            socketChannel.connect(new InetSocketAddress("localhost", 12345));

            while (!socketChannel.finishConnect()) {
                // Ждем завершения соединения
            }

            ByteBuffer buffer = ByteBuffer.allocate(1024);

            // Читаем данные от сервера
            while (socketChannel.read(buffer) != -1) {
                buffer.flip();
                byte[] bytes = new byte[buffer.remaining()];
                buffer.get(bytes);
                System.out.println("Received from server: " + new String(bytes));
                buffer.clear();
            }

            socketChannel.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
Эти примеры демонстрируют неблокирующий TCP-сервер и клиент, которые обмениваются данными по TCP. Сервер принимает подключения от клиентов и отправляет им сообщение "Hello, TCP Client!". Клиент подключается к серверу, читает сообщение и выводит его в консоль.

### 5. Классы SocketChannel и DatagramChannel.
Классы SocketChannel и DatagramChannel являются частями пакета java.nio.channels в Java и предоставляют возможность работы с сетевыми каналами для передачи данных по сети. Вот краткое описание каждого из них:

***SocketChannel:***
*  представляет собой канал для TCP-соединений, то есть для передачи данных по протоколу TCP.
*  поддерживает неблокирующий режим, что означает, что он может использоваться в асинхронных операциях ввода-вывода.
*  можно использовать как для чтения, так и для записи данных из и в сеть.

***DatagramChannel:***
* представляет собой канал для отправки и получения датаграмм (пакетов данных) по протоколу UDP.
* также поддерживает неблокирующий режим, что позволяет использовать его в асинхронных операциях ввода-вывода.
* позволяет отправлять и получать датаграммы без установления соединения, что характерно для протокола UDP.

Вот примеры использования каждого из них:

* Пример использования SocketChannel для TCP-соединений:

```java
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

public class SocketChannelExample {
    public static void main(String[] args) {
        try {
            SocketChannel socketChannel = SocketChannel.open();
            socketChannel.connect(new InetSocketAddress("example.com", 80));

            ByteBuffer buffer = ByteBuffer.allocate(1024);
            buffer.put("GET / HTTP/1.1\r\nHost: example.com\r\n\r\n".getBytes());
            buffer.flip();

            while (buffer.hasRemaining()) {
                socketChannel.write(buffer);
            }

            buffer.clear();
            int bytesRead;
            while ((bytesRead = socketChannel.read(buffer)) != -1) {
                buffer.flip();
                while (buffer.hasRemaining()) {
                    System.out.print((char) buffer.get());
                }
                buffer.clear();
            }

            socketChannel.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
* Пример использования DatagramChannel для UDP-соединений:

```java
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;

public class DatagramChannelExample {
    public static void main(String[] args) {
        try {
            DatagramChannel datagramChannel = DatagramChannel.open();
            datagramChannel.bind(new InetSocketAddress(12345));

            ByteBuffer buffer = ByteBuffer.allocate(1024);
            while (true) {
                buffer.clear();
                InetSocketAddress clientAddress = (InetSocketAddress) datagramChannel.receive(buffer);
                if (clientAddress != null) {
                    buffer.flip();
                    while (buffer.hasRemaining()) {
                        System.out.print((char) buffer.get());
                    }
                    buffer.flip();
                    datagramChannel.send(buffer, clientAddress);
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
Эти примеры демонстрируют основные операции чтения и записи с использованием SocketChannel и DatagramChannel.

### 6. Передача данных по сети. Сериализация объектов.
* Передача данных по сети включает в себя отправку и получение данных между клиентом и сервером через сетевое соединение. Это может включать в себя передачу текстовых строк, бинарных данных или даже объектов.
* Сериализация объектов - это процесс преобразования объекта в последовательность байтов, которая может быть сохранена в файле или передана по сети, а затем восстановлена в исходный объект. В Java сериализация обычно используется для передачи объектов между клиентом и сервером в сети.

### 7. Интерфейс Serializable. Объектный граф, сериализация и десериализация полей и методов.
* Интерфейс Serializable в Java является маркерным интерфейсом, который указывает на то, что класс может быть сериализован, то есть его объекты могут быть преобразованы в последовательность байтов для сохранения в файле, передачи по сети или другим способам, а затем восстановлены в исходное состояние.
* При использовании интерфейса Serializable объекты класса сохраняются вместе со всеми его полями и методами, если они являются сериализуемыми. При сериализации объекта также сериализуются все объекты, на которые он ссылается, образуя таким образом объектный граф. При десериализации объектного графа восстанавливаются все его составляющие объекты.

***Для того чтобы класс мог быть сериализуемым, необходимо выполнить следующие условия:***
* Класс должен реализовывать интерфейс Serializable.

### 8. Java Stream API. Создание конвейеров. Промежуточные и терминальные операции.
***Java Stream API предоставляет удобные и эффективные средства для обработки и манипулирования коллекциями данных в Java. При использовании Stream API можно создавать конвейеры операций, состоящие из промежуточных и терминальных операций.***

* Промежуточные операции применяются к элементам потока и возвращают новый поток с преобразованными элементами. Они могут быть сколь угодно много в цепочке операций, но не выполняются немедленно - они откладываются до вызова терминальной операции.
Примеры промежуточных операций: filter, map, sorted, distinct, limit, skip и другие.

* Терминальные операции завершают конвейер операций и вызывают фактическое выполнение всех промежуточных операций. Они производят результат или побочный эффект. После выполнения терминальной операции нельзя использовать поток еще раз.
Примеры терминальных операций: forEach, collect, reduce, count, anyMatch, allMatch, noneMatch и другие.


***Пример создания конвейера операций с использованием Stream API:***

```java
import java.util.Arrays;
import java.util.List;

public class StreamExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("John", "Alice", "Bob", "Charlie", "David", "Eva");

        long count = names.stream()
                .filter(name -> name.length() > 4) // Промежуточная операция: фильтрация имен по длине
                .map(String::toUpperCase) // Промежуточная операция: преобразование имен в верхний регистр
                .sorted() // Промежуточная операция: сортировка имен
                .peek(System.out::println) // Промежуточная операция: вывод имен в консоль (без изменения потока)
                .count(); // Терминальная операция: подсчет количества элементов

        System.out.println("Number of names: " + count);
    }
}
```
В этом примере список имен фильтруется по длине, преобразуется в верхний регистр, сортируется, выводится в консоль с использованием peek, а затем подсчитывается количество имен с помощью count.

* Важно помнить, что терминальная операция должна быть вызвана для завершения цепочки операций и выполнения всех промежуточных операций. Без терминальной операции промежуточные операции не будут выполнены, потому что поток не будет активирован.
* Все поля класса (или некоторые из них) должны быть сериализуемыми. Для этого они должны быть примитивными типами данных, или также реализовывать интерфейс Serializable, или быть помечены атрибутом transient, чтобы исключить их из сериализации.

### 9. Шаблоны проектирования: Decorator, Iterator, Factory method, Command, Flyweight, Interpreter, Singleton, Strategy, Adapter, Facade, Proxy.

Шаблоны проектирования (Design Patterns) являются bewстановочными решениями для распространенных проблем, возникающих при разработке программного обеспечения. Вот краткое описание каждого из перечисленных вами шаблонов проектирования:

***Decorator (Декоратор):***
* Позволяет добавлять новые функции объектам, не изменяя их структуры.
* Обеспечивает гибкое и расширяемое поведение.

***Iterator (Итератор):***
* Предоставляет способ последовательного доступа к элементам коллекции без раскрытия ее внутреннего представления.
* Повышает уровень абстракции и упрощает работу с коллекциями.

***Factory Method (Фабричный метод):***
* Определяет интерфейс для создания объекта, но оставляет решение о конкретном классе объекта на подклассы.
* Позволяет делегировать ответственность за создание экземпляров подклассам.

***Command (Команда):***
* Инкапсулирует запрос как объект, позволяя клиентам параметризовать клиентские операции историей запросов, отменой и повтором операций.

***Flyweight (Приспособленец):***
* Позволяет эффективно поддерживать множество мелких объектов, разделяя общее состояние между ними.

***Interpreter (Интерпретатор):***
* Определяет грамматику языка и интерпретирует предложения этого языка.
* Применяется для создания интерпретаторов для различных языков и форматов.

***Singleton (Одиночка):***
* Гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к этому экземпляру.

***Strategy (Стратегия):***
* Определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость.
* Позволяет менять поведение объекта во время выполнения.

***Adapter (Адаптер):***
* Позволяет объектам с несовместимыми интерфейсами работать вместе.
* Преобразует интерфейс одного класса в интерфейс, ожидаемый клиентами.

***Facade (Фасад):***
* Предоставляет унифицированный интерфейс для доступа к группе интерфейсов в подсистеме.
* Упрощает использование подсистемы за счет предоставления удобного интерфейса.

***Proxy (Заместитель):***
* Предоставляет объект-заместитель или заполнитель для управления доступом к другому объекту.
* Позволяет контролировать доступ к объекту и добавлять дополнительную логику до и после вызова методов.

***Каждый из этих шаблонов представляет собой проверенные подходы к решению определенного типа задач, и их применение может улучшить архитектуру и расширяемость вашего программного обеспечения.***
